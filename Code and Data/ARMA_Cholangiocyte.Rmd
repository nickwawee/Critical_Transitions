---
title: "Fitting Autoregressive Models to scRNA-seq Expression Levels"
author: "Nick Wawee"
date: "February 23, 2019"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
#setwd("C:/Users/waweenic.BME011/Desktop/730 Updated/Differencing_Methodology/Code and Markdown Small")
library(R.utils)
library(pracma)
library(data.table)
library(tidyr)
library(forecast)
library(ggplot2)
library(tseries)

scalefun<-function(evenlyspaceddata,scaling){
  if(scaling=="statistics" & sd(evenlyspaceddata)!=0){
    scalefun<-(evenlyspaceddata - mean(evenlyspaceddata))/sd(evenlyspaceddata)
  } else if (scaling=="0and1"){
    range=max(evenlyspaceddata)-min(evenlyspaceddata)
    if (range!=0){
      scalefun<-(evenlyspaceddata-min(evenlyspaceddata))/(max(evenlyspaceddata)-min(evenlyspaceddata))
    }else{scalefun<-evenlyspaceddata}
  }
}
mat2numericmat<-function(mat){# this function converts a matrix of class matrix to a numeric matrix
  if (class(mat)=="matrix"){
    newmat<-matrix(0, length(mat[,1]),length(mat[1,]))
    cnames<-colnames(mat)
    rnames<-rownames(mat)
    for (i in 1:length(newmat[,1])){
      newmat[i,]<-sapply(mat[i,],as.numeric)
    }
    row.names(newmat)<-rnames
    colnames(newmat)<-cnames
    mat2numericmat<-newmat
  }else{stop('the matrix is not of the matrix class. class(mat)!=matrix')}
}
createlineargrid<-function(gridlength,Pseudotime,geneexp){
  library(pracma)
  tpgrid=linspace(min(Pseudotime), max(Pseudotime), n=gridlength)#creates emply grid vector for Pseudotime
  expgrid=rep(0,length(tpgrid))#creates empty grid vector for expression values
  for ( ii in 1:gridlength){
    tpvalue=tpgrid[ii]
    upperbounds=Pseudotime[which(Pseudotime>=tpvalue)]
    upperbound=min(upperbounds)
    lowerbounds=Pseudotime[which(Pseudotime<=tpvalue)]
    lowerbound=max(lowerbounds)
    realtp1=lowerbound
    realtp2=upperbound
    realexp2<-as.numeric(unlist(geneexp[match(realtp2,Pseudotime)]))
    realexp1<-as.numeric(unlist(geneexp[match(realtp1,Pseudotime)]))
    if (realtp2==realtp1){
      expgrid[ii]<-realexp2
    }
    else{
      expgrid[ii]=realexp1+(realexp2-realexp1)*(tpvalue-realtp1)/(realtp2-realtp1)
    }
    
  }
  createlineargrid<-cbind(expgrid,tpgrid)
}

```


The purpose of this script is to search through the pseudo-chronological data to see how certain marker gene's expression changes with pseudotime. This script loads a sorted table in pseudo-chronological order of all genes. This script analyzes the hepatocyte branch and outputs a table for the AR-lag coefficient for a sliding window that is 1/10 of the size of the total interpolated (grid) data, and 1/10 of the size of expression data.

#Cholangiocyte Differentiation

##Loading and Filtering

The ordered matrix is loaded generated by the Monocle implementation, and is then filtered to only contain the expressed genes and the cells only associated with the hepatoblast branch of pseudotime. The branch parameter can be changed according to what branch of pseudotime that is being analyzed.

```{r loading}
#Loading
loadmat<-read.table("orderedpt.txt", stringsAsFactors = FALSE)
geneids<-read.table("expressed_genes.txt",stringsAsFactors = FALSE)
genenames<-loadmat[match(geneids[,1],rownames(loadmat)),1]

#Filtering
Branch="Cholangiocyte"#change to Hepatocyte if analyzing Hepatocyte branch
mat<-loadmat[,which(loadmat[2,]=="Hepatoblast"| loadmat[2,]==Branch)]#filters cells only in hepatoblast-cholangiocyte branch
Pseudotime<-as.numeric(mat[1,])
statenumbers=mat[2,]#makes a vector for each cell designation
mat<-mat[match(geneids[,1],rownames(mat)),]
mat<-as.matrix(mat)
row.names(mat)<-genenames
mat<-mat2numericmat(mat)#converts character matrix to numeric matrix
```


##Gene Separation and For-Loop Initialization

Genes are separated into the cluster designations stated by Yang et al.[1], so that they can be analyzed as an example. They are known to undergo transitions during differentiation. The bifurcation point is detected for the last cell that is designated as a hepatoblast. The value and indice is stored for which the suspected critical transition occurs. Parameters are created interpolated sliding window that will slide across the respective branch of pseudotime. The window size that is a function of interpolated pseudotime is 10% the size of the grid.

```{r sep , include=FALSE}
#Separating Cluster Matrix

#Yang Genes
clustera<-c("Foxm1", "Ccna2", "Ccnb1", "Ccne2", "Cdk1")# cell cycle genes
clusterb<-c("Tbx3", "Id3", "Lin28b", "Etv5", "Lgr5")#hepatoblast genes
clusterc<-c("Cps1", "Ppara", "Apoh", "Cyp2d10", "Cyp2d26")#cluster c genes
clusterd<-c("Sox9", "Sox4", "Hnf1b", "Spp1", "Krt7")#cluster d genes
#clustergenes<-c(clustera,clusterb,clusterc,clusterd) used only if Yang genes are to be analyzed.
```

```{r sep2} 
#Critical genes- genes found to undergo critical transition from literature review

critgenesC<-c("Sox9","Sox4","Krt7", "Spp1","Hnf1b", "Nfia", "Zbtb20", "Sox6", "Onecut1", "Jun", "Pbx1", "Onecut2", "Asl", "Sdhd", "Gpt2", "Got2")
critgenesH<-c("Cps1","Cyp2d26", "Nr1h4", "Arg1", "Ppara", "Apoh","Tbx3", "Id3", "Lin28b", "Etv5", "Lgr5")

if (Branch=="Cholangiocyte"){
  clustergenes<-critgenesC
  othergenes<-critgenesH
}else{
  clustergenes<-critgenesH
  othergenes<-critgenesC
}

clustergenes<-c(clustergenes,othergenes)#

clusterexp<-mat[match(clustergenes,rownames(mat)),]
genenum<-nrow(clusterexp)


#Detecting Bifurcation Point
transval<-max(as.numeric(as.character(Pseudotime[which(statenumbers=="Hepatoblast")])))
transind<-max(which(statenumbers=="Hepatoblast"))
gridlength=10000#sets grid length for interpolation
tpgrid<-linspace(min(Pseudotime), max(Pseudotime), n=gridlength)


#Creating initial matrices
ordermat<-matrix(0, nrow= nrow(clusterexp), 3)
colnames(ordermat)<-c('p','d','q')
acfframe<-c('Gene_Name','ACF_Val','Window_Position')
acfframe<-as.data.frame(acfframe)
acfframe<-t(acfframe)
colnames(acfframe)<-acfframe[1,]
acfframe<-data.frame(acfframe, stringsAsFactors = FALSE)
interpolatedexpmat<-matrix(0,length(c(critgenesC,critgenesH))+1,gridlength)#intitializes matrix for interpolated gene expression 
row.names(interpolatedexpmat)<-c("Pseudotime",c(critgenesC,critgenesH))
interpolatedexpmat[1,]<-tpgrid

```


The gene expression levels for the cholangiocyte branch will undergo model fitting and analysis. The succeeding sections are listed by the gene of interest.

#Cholangiocyte Genes

#Sox9

```{r Sox9 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=1
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The ACF plot shows that the successive lags are similar to each other. The scaled expression levels are differenced once and ACF and PACF plot is generated again.

```{r Sox9 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s)
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
```

The ACF function shows that the data are stationary. The ACF has values that exceed 5% statistical significance at 1,2. The PACF values exceed 5% statistical significance at 1 and 2. The others lags that marginally exceed the statistical significant bounds are deemed to exceed the bounds by chance. Since the PACF cuts off after the 2nd lag, an AR(2) model is the best fit. 

A plot of the residuals vs fitted are generated to validate the fit.

```{r Sox9 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

res<-arma(diffvals, order=c(2,0), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

We will say that the data is homoscedastic for this analysis.

The autocorrelation measured by finding the slope between the lag 2 and leading values up until the bifurcation point. This will be called the static measurement.

```{r Sox9 static, echo=FALSE}

d=1
p=2
q=0
ordermat[i,]<-c(p,d,q)

#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
  }

splotvals<-as.data.frame(cbind(lagging,leading))
splotvals<-cbind(splotvals,as.character(rep(genename,length(lagging))),rep(rsquared,length(lagging)),rep(slope,length(lagging)))

colnames(splotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

ggplot(splotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-2 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Sox9 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

We see that there is no correlation.

It is also measured by sliding a window of 10% grid size in increments of 2, and is measured by the lag 2 value at that time point.

```{r Sox9 dynamic}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]
    
    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }

acfframe<-acfframe[-1,]

```


#Sox4

The same process will be underwent for Sox4.

```{r Sox4 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=2
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

It appears that differencing is needed.

```{r Sox4 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF tails off and the PACF cuts off after lag 3, an AR(3) model is appropriate for the stationary expression values for Sox4.

Next the scedasticity will be checked.

```{r Sox4 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

res<-arma(diffvals, order=c(3,0), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Sox4. 

```{r Sox4 static, echo=FALSE}

d=1
p=3
q=0
ordermat[i,]<-c(p,d,q)

#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)

slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }


newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-3 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Sox4 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Sox4 prior to the bifurcation point show no correlation.

```{r Sox4 dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, lag.max=20, plot = FALSE, demean=FALSE)
    slope=res$acf[p+1]

    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```

#Krt7

The same process will be underwent for Krt7.

```{r Krt7 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=3
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Krt7 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF and PACF tail off, an ARMA(1,1) model will be used.

Next the scedasticity will be checked.

```{r Krt7 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

res<-arma(diffvals, order=c(1,1), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedasticity enough.

Next the static autocorrelation will be stored and plotted for Krt7. 

```{r Krt7 static, echo=FALSE}

d=1
p=1
q=1
ordermat[i,]<-c(p,d,q)

#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))


colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')


#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-1 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Krt7 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Krt7 prior to the bifurcation point show a weak positive correlation.

```{r Krt7 dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]
    
    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```

#Spp1

The same process will be underwent for Spp1.

```{r Spp1 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=4
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Spp1 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)

  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF tails off and the PACF cuts off after lag 1, an AR(1) model is appropriate for the stationary expression values for Spp1.

Next the scedasticity will be checked.

```{r Spp1 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=1
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedasticity enough.

Next the static autocorrelation will be stored and plotted for Spp1. 

```{r Spp1 static, echo=FALSE}



#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-1 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Spp1 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Spp1 prior to the bifurcation point show no correlation.

```{r Spp1 dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]

    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```

#Hnf1b

The same process will be underwent for Hnf1b.

```{r Hnf1b plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=5
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
```

The expression levels appear to need differencing.

```{r Hnf1b plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF tails off and the PACF cuts off after lag 2, an AR(2) model is appropriate for the stationary expression values for Hnf1b.

Next the scedasticity will be checked.

```{r Hnf1b fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=2
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Hnf1b. 

```{r Hnf1b static, echo=FALSE}

#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x=c('Lag-2 Stationary Expression Level, TPM'), y='Leading Stationary Expression Level, TPM',title='Hnf1b Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Hnf1b prior to the bifurcation point show no correlation.

```{r Hnf1b dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]
    
    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```


#Nfia

The same process will be underwent for Nfia.

```{r Nfia plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=6
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
```

The expression levels appear to need differencing.

```{r Nfia plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF tails off and the PACF cuts off after lag 3, an AR(3) model is appropriate for the stationary expression values for Nfia.

Next the scedasticity will be checked.

```{r Nfia fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=3
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Nfia. 

```{r Nfia static, echo=FALSE}

#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-3 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Nfia Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Nfia prior to the bifurcation point show no correlation.

```{r Nfia dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]
    
    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```

#Zbtb20

The same process will be underwent for Zbtb20.

```{r Zbtb20 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=7
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Zbtb20 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

The ACF cuts and tails off after lag 2 and the PACF cuts off and semi tails off after lag 2. An AR(2) model will be employed because the PACF displays behavior that 'cuts off' more than the ACF.

Next the scedasticity will be checked.

```{r Zbtb20 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=2
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Zbtb20. 

```{r Zbtb20 static, echo=FALSE}

#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-2 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Zbtb20 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Zbtb20 prior to the bifurcation point show little to no correlation.

```{r Zbtb20 dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]
    
    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```

#Sox6

The same process will be underwent for Sox6.

```{r Sox6 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=8
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
```

The expression levels appear to need differencing.

```{r Sox6 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF tails off and the PACF cuts off after lag 2, an AR(2) model is appropriate for the stationary expression values for Sox6.

Next the scedasticity will be checked.

```{r Sox6 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=2
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedasticenough.

Next the static autocorrelation will be stored and plotted for Sox6. 

```{r Sox6 static, echo=FALSE}
#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-2 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Sox6 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Sox6 prior to the bifurcation point show no correlation.

```{r Sox6 dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]
    
    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```

#Onecut1

The same process will be underwent for Onecut1.

```{r Onecut1 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=9
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Onecut1 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF cuts off after lag 1 and the PACF cuts off after lag 2, the principle of parsimony states that an MA(1) model should be used for this data. The MA coefficient does not provide information regarding to successive stationary values. For the purpose of detecting autocorrelation, an AR(2) model will be used instead.

Next the scedasticity will be checked.

```{r Onecut1 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=2
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Onecut1. 

```{r Onecut1 static, echo=FALSE}
#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-2 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Onecut1 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Onecut1 prior to the bifurcation point show no correlation.

```{r Onecut1 dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]

    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }

```

#Jun

The same process will be underwent for Jun.

```{r Jun plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=10
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Jun plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF tails off and the PACF cuts off after lag 1, an AR(1) model is appropriate for the stationary expression values for Jun.

Next the scedasticity will be checked.

```{r Jun fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=1
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Jun. 

```{r Jun static, echo=FALSE}
#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-1 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Jun Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Jun prior to the bifurcation point show a weak positive correlation.

```{r Jun dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]
    
    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```

#Pbx1

The same process will be underwent for Pbx1.

```{r Pbx1 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=11
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Pbx1 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF cuts off after lag 1 and the PACF cuts off after lag 2, the principle of parsimony states that an MA(1) model should be used for this data. The MA coefficient does not provide information regarding to successive stationary values. For the purpose of detecting autocorrelation, an AR(2) model will be used instead.

Next the scedasticity will be checked.

```{r Pbx1 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=2
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Pbx1. 

```{r Pbx1 static, echo=FALSE}
#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-2 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Pbx1 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Pbx1 prior to the bifurcation point show no correlation.

```{r Pbx1 dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]
    
    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```

#Onecut2

The same process will be underwent for Onecut2.

```{r Onecut2 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=12
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Onecut2 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF cuts off after lag 1 and the PACF cuts off after lag 2, the principle of parsimony states that an MA(1) model should be used for this data. The MA coefficient does not provide information regarding to successive stationary values. For the purpose of detecting autocorrelation, an AR(2) model will be used instead.

Next the scedasticity will be checked.

```{r Onecut2 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=2
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Onecut2. 

```{r Onecut2 static, echo=FALSE}
#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-2 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Onecut2 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Onecut2 prior to the bifurcation point show no correlation. However, there appears to be a linear trend for a set of stationary expression levels. If the pseudotime values are sequential within this portion, the range of pseudotime values could be used to test other expression levels.

```{r Onecut2 dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]

    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```

#Asl

The same process will be underwent for Asl.

```{r Asl plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=13
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Asl plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF cuts off after lag 1 and the PACF cuts off after lag 2, the principle of parsimony states that an MA(1) model should be used for this data. The MA coefficient does not provide information regarding to successive stationary values. For the purpose of detecting autocorrelation, an AR(2) model will be used instead.

Next the scedasticity will be checked.

```{r Asl fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=2
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Asl. 

```{r Asl static, echo=FALSE}
#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-2 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Asl Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Asl prior to the bifurcation point show no correlation.

```{r Asl dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]
    
    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```

#Sdhd

The same process will be underwent for Sdhd.

```{r Sdhd plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=14
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
```

The expression levels appear to need differencing.

```{r Sdhd plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF tails off and the PACF cuts off after lag 1, an AR(1) model is appropriate for the stationary expression values for Sdhd. The change from lag 2 to 3 on the ACF plot was deemed insignificant and ignored because of the principles of parsimony.

Next the scedasticity will be checked.

```{r Sdhd fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=1
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))
```

The linear trend in the middle of the plot shows slight heteroscedasticity. An AR(2) model will be fitted to see if the fit becomes more homoscedastic.

```{r Sdhd fitvsresid2, echo=FALSE}

d=1
p=2
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))
```

The fit appears to displays more homoscedasticity. An AR(2) model will be chosen for Sdhd.

Next the static autocorrelation will be stored and plotted for Sdhd. 

```{r Sdhd static, echo=FALSE}
#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-2 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Sdhd Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Sdhd prior to the bifurcation point show no correlation. There is a trend of select data points as mentioned previously.

```{r Sdhd dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]
    
    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```

#Gpt2

The same process will be underwent for Gpt2.

```{r Gpt2 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=15
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Gpt2 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF tails off and the PACF cuts off after lag 3, an AR(3) model is appropriate for the stationary expression values for Gpt2.

Next the scedasticity will be checked.

```{r Gpt2 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=3
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Gpt2. 

```{r Gpt2 static, echo=FALSE}
#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }

newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-3 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Gpt2 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Gpt2 prior to the bifurcation point show no correlation.

```{r Gpt2 dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]
    
    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```

#Got2

The same process will be underwent for Got2.

```{r Got2 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=16
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Got2 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF cuts off after lag 1 and the PACF cuts off after lag 2, the principle of parsimony states that an MA(1) model should be used for this data. The MA coefficient does not provide information regarding to successive stationary values. For the purpose of detecting autocorrelation, an AR(2) model will be used instead.

Next the scedasticity will be checked.

```{r Got2 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=2
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Got2. 

```{r Got2 static, echo=FALSE}
#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-2 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Got2 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Got2 prior to the bifurcation point show no correlation.

```{r Got2 dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]

    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```

#Hepatocyte-Hepatoblast Genes


#Cps1

```{r Cps1 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=17
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The ACF plot shows that the successive lags are similar to each other. The scaled expression levels are differenced once and ACF and PACF plot is generated again.

```{r Cps1 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s)
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
```

The ACF function shows that the data are stationary. The ACF has values that exceed 5% statistical significance at 1,2. The PACF values exceed 5% statistical significance at 1 and 2. The others lags that marginally exceed the statistical significant bounds are deemed to exceed the bounds by chance. Since the PACF cuts off after the 1st lag, an AR(1) model will be used to model the stationary expression levels for Cps1.

A plot of the residuals vs fitted are generated to validate the fit.

```{r Cps1 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

res<-arma(diffvals, order=c(1,0), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

We will say that the data is homeostatic for this analysis.

The autocorrelation measured by finding the slope between the lag 1 and leading values up until the bifurcation point. This will be called the static measurement.

```{r Cps1 static, echo=FALSE}

d=1
p=2
q=0
ordermat[i,]<-c(p,d,q)

#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
  }

splotvals<-as.data.frame(cbind(lagging,leading))
splotvals<-cbind(splotvals,as.character(rep(genename,length(lagging))),rep(rsquared,length(lagging)),rep(slope,length(lagging)))

colnames(splotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

ggplot(splotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-1 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Cps1 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

We see that there is no correlation.

It is also measured by sliding a window of 10% grid size in increments of 1, and is measured by the lag 1 value at that time point.

```{r Cps1 dynamic}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]
    
    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }

acfframe<-acfframe[-1,]

```


#Cyp2d26

The same process will be underwent for Cyp2d26.

```{r Cyp2d26 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=18
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

It appears that differencing is needed.

```{r Cyp2d26 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF tails off and the PACF cuts off after lag 1, an AR(1) model is appropriate for the stationary expression values for Cyp2d26.

Next the scedascity will be checked.

```{r Cyp2d26 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

res<-arma(diffvals, order=c(1,0), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Cyp2d26. 

```{r Cyp2d26 static, echo=FALSE}

d=1
p=1
q=0
ordermat[i,]<-c(p,d,q)

#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)

slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }


newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-1 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Cyp2d26 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Cyp2d26 prior to the bifurcation point show little to no correlation.

```{r Cyp2d26 dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, lag.max=20, plot = FALSE, demean=FALSE)
    slope=res$acf[p+1]

    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```


#Nr1h4

The same process will be underwent for Nr1h4.

```{r Nr1h4 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=19
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

It appears that differencing is needed.

```{r Nr1h4 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF cuts off after lag 1 and the PACF cuts off after lag 2, the principle of parsimony states that an MA(1) model should be used for this data. The MA coefficient does not provide information regarding to successive stationary values. For the purpose of detecting autocorrelation, an AR(2) model will be used instead.

Next the scedascity will be checked.

```{r Nr1h4 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

res<-arma(diffvals, order=c(2,0), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Nr1h4. 

```{r Nr1h4 static, echo=FALSE}

d=1
p=2
q=0
ordermat[i,]<-c(p,d,q)

#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)

slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }


newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-3 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Nr1h4 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Nr1h4 prior to the bifurcation point show no correlation.

```{r Nr1h4 dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, lag.max=20, plot = FALSE, demean=FALSE)
    slope=res$acf[p+1]

    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```

#Arg1

The same process will be underwent for Arg1.

```{r Arg1 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=20
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Arg1 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)

  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF tails off and the PACF cuts off after lag 1, an AR(1) model is appropriate for the stationary expression values for Arg1.

Next the scedascity will be checked.

```{r Arg1 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=1
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Arg1. 

```{r Arg1 static, echo=FALSE}

#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-1 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Arg1 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Arg1 prior to the bifurcation point show no correlation.

```{r Arg1 dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]

    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```

#Ppara

The same process will be underwent for Ppara.

```{r Ppara plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=21
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Ppara plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)

  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF tails off and the PACF cuts off after lag 1, an AR(1) model is appropriate for the stationary expression values for Ppara.

Next the scedascity will be checked.

```{r Ppara fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=1
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Ppara. 

```{r Ppara static, echo=FALSE}

#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }

newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-1 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Ppara Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Ppara prior to the bifurcation point show a weak positive correlation.

```{r Ppara dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]

    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```

#Apoh

The same process will be underwent for Apoh.

```{r Apoh plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=22
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Apoh plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)

  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF tails off and the PACF cuts off after lag 1, an AR(1) model is appropriate for the stationary expression values for Apoh.

Next the scedascity will be checked.

```{r Apoh fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=1
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Apoh. 

```{r Apoh static, echo=FALSE}

#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
resids<-resids[-which(is.na(res))]
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-1 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Apoh Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Apoh prior to the bifurcation point show a positive correlation.

```{r Apoh dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]

    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }


```

#Tbx3

The same process will be underwent for Tbx3.

```{r Tbx3 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=23
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Tbx3 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)

  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF tails off and the PACF cuts off after lag 1, an AR(1) model is appropriate for the stationary expression values for Tbx3.

Next the scedascity will be checked.

```{r Tbx3 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=1
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Tbx3. 

```{r Tbx3 static, echo=FALSE}

#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-1 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Tbx3 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Tbx3 prior to the bifurcation point show a weak positive correlation.

```{r Tbx3 dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]

    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }
```

#Id3

The same process will be underwent for Id3.

```{r Id3 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=24
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Id3 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)

  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF cuts off after lag 0 and the PACF cuts off after lag 2, an AR(2) model is appropriate for the stationary expression values for Id3.

Next the scedascity will be checked.

```{r Id3 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=2
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Id3. 

```{r Id3 static, echo=FALSE}

#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-2 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Id3 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Id3 prior to the bifurcation point show no correlation.

```{r Id3 dynamic, include=FALSE}

#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]

    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }
```


#Lin28b

The same process will be underwent for Lin28b.

```{r Lin28b plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=25
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Lin28b plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF cuts off after lag 0 and the PACF cuts off after lag 1, an AR(1) model is appropriate for the stationary expression values for Lin28b.

Next the scedascity will be checked.

```{r Lin28b fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=1
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))


```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Lin28b. 

```{r Lin28b static, echo=FALSE}

#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-1 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Lin28b Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Lin28b prior to the bifurcation point show a weak positive correlation.

```{r Lin28b dynamic, include=FALSE}
#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]

    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }
```

#Etv5

The same process will be underwent for Etv5.

```{r Etv5 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=26
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Etv5 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)
  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF cuts off after lag 0 and the PACF cuts off after lag 1, an AR(1) model is appropriate for the stationary expression values for Etv5.

Next the scedascity will be checked.

```{r Etv5 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=1
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))
```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Etv5. 

```{r Etv5 static, echo=FALSE}

#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-1 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Etv5 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Etv5 prior to the bifurcation point show a weak positive correlation.

```{r Etv5 dynamic, include=FALSE}
#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]

    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }
```

#Lgr5

The same process will be underwent for Lgr5.

```{r Lgr5 plot 1, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  i=27
  #Interpolation and Scaling
  genename<-rownames(clusterexp)[i]
  gridres<-createlineargrid(gridlength,Pseudotime,clusterexp[i,])
  exp.i<-gridres[,1]
  interpolatedexpmat[i+1,]<-exp.i
  exp.s<-scale(exp.i)
  
  acfres<-acf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(exp.s, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')
  
```

The expression levels appear to need differencing.

```{r Lgr5 plot 2, out.width=c('50%', '50%'), fig.show='hold', echo=FALSE }
  diffvals<-diff(exp.s, differences=1)

  acfres<-acf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(acfres, main='ACF')
  pacfres<-pacf(diffvals, lag.max = 20, demean=FALSE, plot=FALSE)
  plot(pacfres, main='PACF')

```

Since the ACF tails off and the PACF cuts off after lag 1, an AR(1) model is appropriate for the stationary expression values for Lgr5.

Next the scedascity will be checked.

```{r Lgr5 fitvsresid, echo=FALSE, warning=FALSE, message=FALSE}

d=1
p=1
q=0
ordermat[i,]<-c(p,d,q)

res<-arma(diffvals, order=c(p,q), include.intercept = FALSE)
fitvals<-fitted(res)#stores fitted values
resvals<-res$residuals#stores residual values
plotvals<-as.data.frame(cbind(fitvals,resvals))
colnames(plotvals)<-c('Fitted_Values', 'Residual_Values')
plotvals<-plotvals[-which(is.na(plotvals[,1])),]


ggplot(plotvals, aes(x=Fitted_Values, y=Residual_Values))+
  geom_point()+
  theme_minimal()+
  labs(x='Stationary Fitted Values, TPM', y='Stationary Residual Values, TPM')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The fit appears to be homoscedastic enough.

Next the static autocorrelation will be stored and plotted for Lgr5. 

```{r Lgr5 static, echo=FALSE}

#Static measurement

yvals=diffvals[1:(max(which(tpgrid<=transval))-d)]
fit=arma(yvals, order=c(p,q), include.intercept = FALSE)
resids<-fit$residuals
ybar=mean(yvals)
slope=fit$coef[p]

lagging=yvals[1:(length(yvals)-p)]
leading=yvals[(1+p):length(yvals)]

#calculating r^2
SST=sum((yvals-ybar)^2)
  if (SST>0){
    rsquared=1-sum(resids^2)/(SST)
  }else{
      rsquared=1
    }



newsplotvals<-data.frame(cbind(lagging,leading,rep(genename,length(lagging)),as.numeric(rep(rsquared,length(lagging))),as.numeric(rep(slope,length(lagging)))))
colnames(newsplotvals)<-c('Lagging','Leading', 'Gene_Name','rsquared','slope')

#Changing numbers to numeric
newsplotvals$Lagging<-as.numeric(as.character(newsplotvals$Lagging))
newsplotvals$Leading<-as.numeric(as.character(newsplotvals$Leading))
newsplotvals$rsquared<-as.numeric(as.character(newsplotvals$rsquared))
newsplotvals$slope<-as.numeric(as.character(newsplotvals$slope))

splotvals<-rbind(newsplotvals,splotvals)

ggplot(newsplotvals, aes(x=Lagging, y=Leading))+
  geom_point()+
  theme_minimal()+
  labs(x='Lag-1 Stationary Expression Level, TPM', y='Leading Stationary Expression Level, TPM',title='Lgr5 Autocorrelation')+
  theme(panel.grid.minor=element_blank(), panel.grid.major = element_blank(), axis.ticks.x = element_line(colour='black'),axis.ticks.y =    element_line(colour='black'), plot.title = element_text(hjust=0.5, face='bold'))

```

The stationary expression levels for Lgr5 prior to the bifurcation point show a weak positive correlation.

```{r Lgr5 dynamic, include=FALSE}
#Dynamic measurement  
windowlength<-0.1*gridlength
jval<-(length(exp.s)-d-windowlength)%/%p#finds how many times the window can iterate before the window exceeds pseudotime by finding the quotient
  for(j in 1:jval){
    #Storing stationary expression
    windowposition<-windowlength+j*p
    windowexp<-exp.s[(j*p):windowposition]
    if (d>0){
    statvals<-diff(ts(windowexp),differences=d)#differences data acording to ARIMA model
    }else{
      statvals<-windowexp
    }
    #Calculations
    yvals=statvals
    ybar=mean(yvals)
    res<-acf(yvals, demean=FALSE, plot=FALSE, lag.max=20)
    slope=res$acf[p+1]

    #Storing
    tpval<-tpgrid[windowposition]# stores pseudotime value at the end of the sliding window
    newrow<-c(genename, slope, tpval,rsquared)# creates a new row to put in dataframe
    acfframe<-rbind(acfframe, newrow)
  }
```



```{r table writing, include=FALSE}
dynamicvals<-acfframe
colnames(dynamicvals)<-c('Gene_Name','ACF_Val','Pseudotime')
dynamicvals$Gene_Name<-factor(dynamicvals$Gene_Name)
dynamicvals$Pseudotime<-as.numeric(dynamicvals$Pseudotime)
dynamicvals$ACF_Val<-as.numeric(dynamicvals$ACF_Val)

expdf<-as.data.frame(t(interpolatedexpmat))
exp.m<-melt(expdf, id.vars='Pseudotime')
names(exp.m)<-c('Pseudotime','Gene_Name','Expression_Level')
newdf<-merge(exp.m, dynamicvals)

staticvals<-splotvals

write.table(newdf,'cholangiocytedynamicvals.txt')
#write.table(exp.m, 'cholangiocyteexpvals.txt')
write.table(staticvals,'cholangiocytestaticvals.txt')
write.table(ordermat,'cholangiocyteordermat.txt')
```


##Envrionment and References

System environment is shown below
```{r env, echo=FALSE}
Sys.getenv()
```

###References

[1] Yang, L. , Wang, W. , Qiu, W. , Guo, Z. , Bi, E. and Xu, C. (2017), A single-cell transcriptomic analysis reveals precise pathways and regulatory mechanisms underlying hepatoblast differentiation. Hepatology, 66: 1387-1401. doi:10.1002/hep.29353

[2] V. Dakos, M. Scheffer, E. H. van Nes, V. Brovkin, V. Petoukhov, and H. Held, "Slowing down as an early warning signal for abrupt climate change," PNAS, 10-Sep-2008. [Online]. Available: http://www.pnas.org/content/early/2008/09/10/0802430105. [Accessed: 27-Jul-2018]. 


#Additional Resources

http://www.pnas.org/content/suppl/2008/09/11/0802430105.DCSupplemental/0802430105SI.pdf#nameddest=SF2 - Dakos SI

http://a-little-book-of-r-for-time-series.readthedocs.io/en/latest/src/timeseries.html - Time series for R



